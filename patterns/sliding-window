ğŸŒŸ What Is the Sliding Window Pattern?

A sliding window is a technique used to process contiguous ranges inside arrays or strings efficiently.

Instead of recomputing the work for every subarray from scratch (which takes O(nÂ·k)), sliding window lets you reuse previous computation so the time drops to O(n).

ğŸ§  When Do We Use Sliding Window?

Look for these signals:

âœ”ï¸ The problem involves subarrays or substrings

â†’ â€œFind longest substringâ€¦â€,
â†’ â€œCount subarraysâ€¦â€
â†’ â€œMaximum sum of size kâ€¦â€

âœ”ï¸ The answer is based on a contiguous region

If order matters and you canâ€™t rearrange, itâ€™s a strong hint.

âœ”ï¸ You add/remove elements as the window expands/contracts

Meaning you can update state in O(1) time.

âš™ï¸ Two Types of Sliding Window
ğŸ”¹ 1. Fixed-size window

Window size is always k, and it moves one step at a time.

ğŸ‘‰ Used when the problem explicitly says â€œsize kâ€.

Example problem:

Max sum subarray of size k

Template:
l = 0
curr = 0
for r in range(len(nums)):
    curr += nums[r]

    if r - l + 1 == k:
        # process window
        answer = max(answer, curr)
        curr -= nums[l]
        l += 1

ğŸ”¹ 2. Dynamic window

Window size grows until it violates a rule, then shrinks.

ğŸ‘‰ Used for problems involving:

Longest substring with â‰¤ K distinct characters

Smallest substring that contains all characters of target

Longest substring with no repeats

Template:
l = 0
window = {}  # frequency map

for r in range(len(s)):
    window[s[r]] = window.get(s[r], 0) + 1

    while condition_is_violated:
        window[s[l]] -= 1
        if window[s[l]] == 0:
            del window[s[l]]
        l += 1

    # valid window here
    result = max(result, r - l + 1)

ğŸ¯ Core Idea of Sliding Window

Think of a window [l, r].

Moving the right pointer:

Adds a new element to the window

Expands the window

Increases sum/count/frequency

Moving the left pointer:

Removes an element

Shrinks the window

Helps restore a constraint

The magic is:
at most N moves for l and N moves for r â†’ O(N)

ğŸ“˜ Example #1 (Classic)
Longest Substring Without Repeating Characters

ğŸ§  Dynamic window
Keep shrinking when duplicates appear.

Code:
def lengthOfLongestSubstring(s):
    seen = set()
    l = 0
    best = 0

    for r in range(len(s)):
        while s[r] in seen:
            seen.remove(s[l])
            l += 1
        
        seen.add(s[r])
        best = max(best, r - l + 1)

    return best

ğŸ“˜ Example #2
Minimum Window Substring (hard)

Dynamic window with counts.

Steps:

Add characters until valid

Shrink from left to find minimum

Repeat

ğŸ“˜ Example #3
Max Sum of Subarray Size K

Fixed window.

def maxSum(nums, k):
    l = 0
    curr = 0
    best = float('-inf')

    for r in range(len(nums)):
        curr += nums[r]

        if r - l + 1 == k:
            best = max(best, curr)
            curr -= nums[l]
            l += 1

    return best

ğŸ‘‘ The 4 Sliding Window Patterns You Will See on LeetCode
1ï¸âƒ£ Fixed window size

â¡ï¸ Max sum of size k, average, count of windows, etc.

2ï¸âƒ£ Longest substring / subarray under a constraint

â¡ï¸ â€œLongest substring with at most K distinct charsâ€
â¡ï¸ â€œLongest substring without repeatâ€

3ï¸âƒ£ Smallest substring / subarray that meets requirement

â¡ï¸ â€œMinimum window substringâ€
â¡ï¸ â€œSmallest subarray with sum â‰¥ targetâ€

4ï¸âƒ£ Variable constraints using frequency maps

â¡ï¸ Find permutation, anagram, or pattern inside a window
â¡ï¸ Check if window matches target frequency
